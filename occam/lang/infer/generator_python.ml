open Schema
module G = Generator

module Snippet = struct
  (* let import_future = {|from __future__ import annotations|} *)

  let import_abc = {|from abc import abstractmethod, ABC|}
  let import_dataclases = {|import dataclasses|}
  let import_dataclass = {|from dataclasses import dataclass|}

  let imports =
    String.concat "\n"
      [ (* import_future;  *) import_abc; import_dataclases; import_dataclass ]

  let dataclass_decorator = "@dataclass"

  let class_name_of name =
    name |> String.split_on_char '_'
    |> List.map String.capitalize_ascii
    |> String.concat ""

  let class_decl_of name = Printf.sprintf "class %s:" (class_name_of name)

  let abc_class_decl_of name =
    Printf.sprintf "class %s(ABC):" (class_name_of name)

  let%test _ = class_name_of "example_request" = "ExampleRequest"
  let%test _ = class_name_of "echo_message" = "EchoMessage"

  let classmethod_decorator = "@classmethod"
  let abstract_method_decorator = "@abstractmethod"
  let from_dict_header = "def from_dict(cls, data: dict):"
  let to_dict_method = "def to_dict(self):"
  let pass_statement = "pass"

  let method_signature name req res =
    Printf.sprintf "def %s(self, request: %s) -> %s:" name (class_name_of req)
      (class_name_of res)

  let field_decl name typ = Printf.sprintf "%s: %s" name typ

  let service_name_of name =
    if String.ends_with name ~suffix:"service" then name
    else Printf.sprintf "%s_service" name

  let header_notification =
    {|# Generated by infer_gen from infer schema file.
# !!!WARNING!!! do not modify this file directly.
# See README of infer generator for more details.
#      play/common/values/infer/README.md
# pylint: disable=duplicate-code,unused-argument,use-dict-literal,wrong-import-order
|}

  let quote s = Printf.sprintf "\"%s\"" s
  let data_of t = Printf.sprintf "data[%s]" (quote t)

  let list_comprehension expr scope_var collection =
    Printf.sprintf "[%s for %s in %s]" expr scope_var collection

  let self_accessor name = Printf.sprintf "self.%s" name
end

open Occam_ext.Buf.Text
open Occam_ext.Fn

type py_type =
  | PyInt
  | PyStr
  | PyBool
  | PyFloat
  | PyList of py_type
  | PyDict of py_type * py_type
  | PyDynDict
  | PyCustomizedType of string
  | PyOption of py_type

let direct_type_to_pytype = function
  | "str" -> PyStr
  | "int" -> PyInt
  | "bool" -> PyBool
  | "float" -> PyFloat
  | t -> PyCustomizedType t

let rec python_type_alias = function
  | DirectType t -> direct_type_to_pytype (t |> unwrap)
  | StringType -> PyStr
  | NumberType -> PyInt
  | ArrayType t -> PyList (python_type_alias t)
  | UnionType [ NullType; t ] -> PyOption (python_type_alias t)
  | UnionType [ t; NullType ] -> PyOption (python_type_alias t)
  | UnionType _ -> G.unsupported "Only allowed optional type."
  | MappingType (key, value) ->
      PyDict (python_type_alias key, python_type_alias value)
  | AnyType -> PyDynDict
  | tb ->
      G.unsupported
        (Printf.sprintf "Unsupported type alias in Python %s"
           (show_type_body tb))

let rec py_type_repr = function
  | PyInt -> "int"
  | PyStr -> "str"
  | PyBool -> "bool"
  | PyFloat -> "float"
  | PyList t -> Printf.sprintf "list[%s]" (py_type_repr t)
  | PyDict (l, r) ->
      Printf.sprintf "dict[%s, %s]" (py_type_repr l) (py_type_repr r)
  | PyDynDict -> "dict"
  | PyCustomizedType t -> t
  | PyOption t -> Printf.sprintf "Option[%s]" (py_type_repr t)

let gen_field (Identifier name) typ =
  indent 2
  *> append (Snippet.field_decl name (py_type_repr (python_type_alias typ)))
  *> endline

let field_needs_customize _ typ =
  let rec pytype_needs_customize = function
    | PyList t -> pytype_needs_customize t
    | PyDict (l, r) -> pytype_needs_customize l || pytype_needs_customize r
    | PyCustomizedType _ -> true
    | PyOption _ -> true
    | _ -> false
  in
  pytype_needs_customize (python_type_alias typ)

let next_scope_var current =
  if String.length current > 1 then "i"
  else
    let ch = String.get current 0 in
    String.of_seq (List.to_seq [ Char.chr (Char.code ch + 1) ])

let rec from_dict_of name ~scope_var = function
  | PyCustomizedType t -> Printf.sprintf "%s.fromDict(%s)" t scope_var
  | PyList t ->
      let new_scope_var = next_scope_var scope_var in
      let expr = from_dict_of name ~scope_var:new_scope_var t in
      Snippet.list_comprehension expr new_scope_var scope_var
  | PyOption t ->
      from_dict_of name t ~scope_var
      ^ Printf.sprintf " if %s in data and %s is not None else None"
          (Snippet.quote name) scope_var
  | _ -> G.unsupported "Unsupported from_dict type"

let gen_type_method generator scope_var_ext (Identifier name) typ =
  indent 6
  *> append (Snippet.quote name)
  *> append ": "
  *> append
       (generator name ~scope_var:(scope_var_ext name) (python_type_alias typ))
  *> append "," *> endline

let rec to_dict_of name ~scope_var = function
  | PyCustomizedType _ -> Printf.sprintf "%s.to_dict()" scope_var
  | PyList t ->
      let new_scope_var = next_scope_var scope_var in
      Snippet.list_comprehension
        (to_dict_of name ~scope_var:new_scope_var t)
        new_scope_var scope_var
  | PyOption t ->
      Printf.sprintf "None if %s is None else %s" scope_var
        (to_dict_of name ~scope_var t)
  | _ -> G.unsupported "Unsupported to_dict type"

let gen_from_dict fields =
  bind_into
    [
      indent 2 *> append Snippet.classmethod_decorator *> endline;
      indent 2 *> append Snippet.from_dict_header *> endline;
      indent 4 *> append "return cls(**{" *> endline;
      indent 6 *> append "**data," *> endline;
      bind_into
        (fields
        |> List.filter (uncurry field_needs_customize)
        |> List.map (uncurry (gen_type_method from_dict_of Snippet.data_of)));
      indent 4 *> append "})" *> endline;
    ]

let gen_to_dict fields =
  bind_into
    [
      indent 2 *> append Snippet.to_dict_method *> endline;
      indent 4 *> append "return {" *> endline;
      indent 6 *> append "**dataclasses.asdict(self)," *> endline;
      bind_into
        (fields
        |> List.filter (uncurry field_needs_customize)
        |> List.map (uncurry (gen_type_method to_dict_of Snippet.self_accessor))
        );
      indent 4 *> append "}" *> endline;
    ]

(* TODO: generate from_dict and to_dict methods *)
let gen_record id fields =
  bind_into
    [
      append Snippet.dataclass_decorator *> endline;
      append (Snippet.class_decl_of id) *> endline;
      bind_into (List.map (uncurry gen_field) fields);
      endline;
      gen_from_dict fields;
      endline;
      gen_to_dict fields;
      endline;
      endline;
    ]

let gen_type id type_body =
  match type_body with
  | RecordType fields -> gen_record id fields
  | _ -> G.unsupported "Unsupported type body"

let gen_method m =
  match m with
  | MethodDeclaration (Identifier name, Identifier req_t, Identifier res_t) ->
      bind_into
        [
          indent 2 *> append Snippet.abstract_method_decorator *> endline;
          indent 2
          *> append (Snippet.method_signature name req_t res_t)
          *> endline;
          indent 4 *> append Snippet.pass_statement *> endline;
          endline;
        ]

let gen_service name methods =
  let svc_class_name =
    name |> Snippet.service_name_of |> Snippet.class_name_of
  in
  let svc_class_decl = svc_class_name |> Snippet.abc_class_decl_of in
  bind_into
    [
      append svc_class_decl *> endline;
      endline;
      bind_into (List.map gen_method methods);
    ]

let gen_decl decl =
  match decl with
  | TypeDeclaration (Identifier name, _, type_body) -> gen_type name type_body
  | ServiceDeclaration (Identifier name, methods) -> gen_service name methods
  | _ -> G.unsupported "Unsupported decls"

let gen (schema : Schema.t) : string =
  let buffer = Buffer.create 256 in
  buffer
  |> bind_into
       [
         append Snippet.header_notification *> endline;
         append Snippet.imports *> endline;
         endline;
         endline;
         bind_into (List.map gen_decl schema);
       ];
  buffer |> Buffer.to_bytes |> Bytes.to_string

let%test _ =
  let () =
    print_endline
      (gen
         (G.parse
            {|
    type echo_message = {
      message: string,
      attributes: map<str, str>,
      some_attribute: SomeType,
      another_attributes: [[AnotherType]],
      yet_another_attribute: AnotherType?
    }

    service echo {
      echo (echo_message): echo_message
    }
  |}))
  in
  true
